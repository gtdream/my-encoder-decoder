StringBuffer.append("sdfdsf");
invoking할때 "sdfdsf" String object 생성

왜 String object는 immutable인가?

왜 윈도우에서 io buffer크기는 8192byte를 기본으로 사용할까?

main의 argument로 받는 String의 encoding type은 무엇인가?
콘솔에서 사용하는 codepage의 encoding type으로 들어감
new String(입력문자열, 콘솔 인코딩)


BMP내의 문자는 surrogate영역의 값이 다 똑같고
surrogate값이 바뀌면 다른 MP를 참조한다

for (int j = 0; j < 3; j++) {
	for (int i = 0; i < Byte.SIZE; i++) {
		System.out.print((buffer[j] >> Byte.SIZE - (i+1)) & 0x1);
	}
	System.out.print(' ');
}

i18n를 사용한 프로그램의 특징들
1.현지화 데이터의 추가를 통해 전세계에서 동작할 수 있다
2.화면에 출력하는 메세지와 GUI label같은 것들을 일일이 바꿔주는 작업이 필요없다
3.새로운 다른 언어를 지원하기위해 recompliation할 필요없다
4.날짜/시간, 통화같은 문화적으로 연관된 데이터들이 최종 사용자의 지방과 언어에 맞는 형식으로 나타난다
5.빠르게 현지화를 할 수 있다

i18n 지원을 위한 단계
1. properties file들을 만든다
hi = 안녕
lanch = 점심
등등......
=을 기준으로 왼쪽은 오른쪽 문자열에 대응하는 key로 볼 수 있다
properties파일은 fileName_언어_국가.properties 형식의 이름으로 저장한다
fileName, 언어, 국가는 임의로 지을 수 있지만 직관적으로 하는 것이 좋다

2. properties file 사용하기
Locale class를 통해 다양한 language, country를 지정한다
Locale object를 생성할 때 language, country 를 constructor의 parameter로 넣는다
다음 ResourceBundle class를 사용해 properties에 작성한 data를 사용할 수 있는데
ReousrceBundle.getBundle(fileName, Locale) method를 사용해 properties의 data를 hashtable로 만들고 ResourceBundle object를 얻는다.
이렇게 얻어낸 ResourceBundle object의 getString(key)를 사용해 지정한 language, country에 맞는 data를 얻을 수 있다

3. i18n은 다음 사항을 필수로 확인해야 한다
1. 화면에 표시하는 message
2. GUI에 출력되는 label
3. online 도움말
4. sounds
5. colors
6. graphics
7. 시간/날짜/숫자/통화/전화번호/존칭,직급/주소/page layouts

Isolate Translatable Text in Resource Bundles
(Resource Bundles안의 변환할 수 있는 text 격리하기)
변환에는 비용든다. text를 격리하므로써 비용을 줄이는데 도움이 되는데 반드시 ResourceBundle object안에서 변환되어 있어야 한다.
변환할 수 있는 text는 status message, error message, log file entries, GUI label을 포함한다. 이 text는 프로그램안으로 하드코딩되고 국제화되어 있지 않다.
하드코딩된 text들 모두를 Resource Bundles로 위치시키는 것이 필요하고********
아래처럼 작성된 부분은 모두 재정리를 해야한다
String label = "ok";
JButton button = new JButton(label);

Setting the locale
국제화된 프로그램은 정보를 전세계에 다르게 보여줄 수 있다.
다양한 언어/국가별로 국제화된 프로그램을 어떻게 식별하여 사용할 수 있을까?
Locale object를 참조하여 쉽게 할 수 있다.
Locale object는 언어와 지역을 결합하여 명세하기 위한 고유의 식별자다.
한 class가 Locale에 따라 적합하게 동작하도록 변한다면 locale-sensitive라고 말한다.
NumberFormat class는 locale-sensitive이다. 숫자의 형식은 Locale에 의존하여 반환한다.
Locale object는 오직 식별자이다.

Creating a Locale
Locale object를 만들려면 대표적인 언어code와 지역code를 명시한다.
같은 영어권이지만 지역이 다른 미국(Unite States)와 영국(Grate Britian)에 해당하는 Locale object를 만든는 예제다
Locale usLocale = new Locale("en", "US");
Locale brLocale = new Locale("en", "GB");
첫번째 argument는 언어code로 2개의 소문자로 ISO-639를 따른다.
두번째 argument는 지역code로 2개의 대문자로 ISO-3166을 따른다.
이것외에 구분을 해야 할 필요가 있다면 3번째 parameter를 명시할 수 있는데 variant code라고 한다. 대부분 variant code는 computing platform을 명시한다.
같은 언어와 지역이지만 다른 OS일 경우의 예제다
Locale usLocale = new Locale("en", "US", "UNIX");
Locale usLocale = new Locale("en", "US", "WINDOWS");
variant code는 표준이 없다. variant code로 만들어진 Locale object는 해당 application만 알수있다.
지역code와 variant code는 선택적이다.지역code를 넣지 않았다면  ""을 명시한다.
Locale usLocale = new Locale("en", "");
편한 방법으로 사용할수 있게 Locale class에서 몇몇 언어와 국가의 constant를제공한다.
다음 두 문장은 같은 Locale object를 생성한다.
Locale brLocale = Locale.JAPAN;
Locale usLocale = new Locale("ja", "JP");
언어 constant는 지역은 정의되지 않았다
다음 두 문장은 같은 Locale object를 생성한다.
Locale brLocale = Locale.JAPANESE;
Locale usLocale = new Locale("ja", "");

Identifying Available Locales
Locale object는 단지 식별자일 뿐이다.
Locale object가 다른 object로 넘겨져야 진짜 작업을 한다.
이러한 다른 object를 locale-sensitive라고 부른다.
locale-sensitive class가 인식할 수 있는 Locale선언 종류는 getAvailableLocales method로 찾아낼 수 있다.
Locale list를 반환하는데 toString method로 출력할 수 있다.
지역과 언어코드사이에 unserscore를 넣어 구분한다.
알기쉽게 볼수 있도록 출력하기 위해서 getDisplayName method를 호출한다.
출력되는 list는 java platform 구현에 의존하므로 다르게 나올 수 있다.

The Scope of a Locale
java platform은 프로그램 전체에 쭉 같은 locale을 사용하는 것을 요구하지 않는다.
원한다면 프로그램내부의 모든 locale-sensitive object에 다른 Locale을 할당할 수 있다.
이 유연함은 여러나라말의 applications를 개발할 수 있게한다.
이렇더라도 대부분의 applications는 여러나라말로 되지 않았고 locale-sensitive objects는 default Locale에 의지한다. JVM이 시작할 때 Locale이 set되는데 default locale은 host platform의 locale로 맞추어진다.
JVM의 default Locale로 결정하기위해 Locale.getDefault method를 호출한다.
default Locale은 프로그램적으로 set하지 말이야 한다. 모든 locale-sensitive classes에 의해 공유되기 때문이다.
Locale-Sensitive Services SPI
이것의 특징은 locale의존적인 data와 서비스의 plug-in이 가능하게 한다.
이 방법을 통해 third parites는 java.text, java.util pacakage안의 대부분의 locale-sensitive의 구현을 제공할 수 있다.
SPIs의 구현은 abstract class와 interface에 기반을 두고 서비스 제공자에 의해 구현된다.
다음과 같은 locale sensitive 구현을 사용할 수 있다.
l	BreakIterator objects
l	Collator objects
l	Language code, Country code, and Variant name for the Locale class
l	Time Zone names
l	Currency symbols
l	DateFormat objects
l	DateFormatSymbol objects
l	NumberFormat objects
l	DecimalFormatSymbols objects 

2개 package java.util.spi와 java.text.spi에 위의 SPIs를 전부 담고 있다.
java.util.spi	java.text.spi
l	CurrencyNameProvider
l	LocaleServiceProvider
l	TimeZoneNameProvider	l	BreakIteratorProvider
l	CollatorProvider
l	DateFormatProvider
l	DateFormatSymbolsProvider
l	DecimalFormatSymbolsProvider
l	NumberFormatProvider

새로운 locale을 위해 NumberFormat object를 제공하는 것을 원한다면 java.text.spi package에 NumberFormatProvider class를 구현해야 한다.
이 class를 확장하고 아래 methods를 구현할 필요가 있다.
getCurrentcyInstance(Locale locale)
getIntegerInstance(Locale locale)
getNumberInstance(Locale locale)
getPercentInstance(Local loca)
사용예)
Locale loc = new Locale("da", "DK");
NumberFormat nf = NumberFormatProvider.getNumberInstance(loc);
구현한 methods는 가장 먼저 요청된 locale의 jre이 지원여부를 검사한다.
지원한다면 그대로 사용한다.
지원하지 않는 다면 위 methods는 설치된 providers의 getAvailableLocales() method를 호출한다. 요청된 locale을 지원하는 provider를 찾기위해.

Lesson : Isolating Locale-Specific Data
About the ResourceBundle Class
How a ResourceBundle is Related to a Locale
개념적으로 각각의 ResourceBundle은 같은 base name을 공유하는 관련된 subclass의 집합이다.
ButtonLabel base name
ButtonLabel_de base name_language code
ButtonLabel_en_GB base name_language_code_coutry_code
ButtonLabel_fr_CA_UNIX name_language_code_coutry_code_variant code
적합한 ResourceBundle을 선택하기 위하여 ResourceBundle.getBundle method를 호출한다. 아래 예제는 French, Canada, UNIX에 맞는 Locale을 위한 ButtonLabel ResourceBundle을 선택하는 예제다.
Locale currentLocale = new Locale("fr", "CA", "UNIX");
ResourceBundle introLabels =
    ResourceBundle.getBundle("ButtonLabel", currentLocale);
만약 위에서 명시된 Locale을 위한 ResourceBundle class가 없으면 getBundle은 가깝게 일치하는 것을 찾기위해 여러번 시도한다.
ButtonLabel_fr_CA_UNIX가 원래 원하던 것이고 default Locale은 en_US라면 getBundle은 다음 순서로 조사할 수 있다.
ButtonLabel_fr_CA_UNIX
ButtonLabel_fr_CA
ButtonLabel_fr
ButtonLabel_en_US
ButtonLabel_en
ButtonLabel
Note that getBundle looks for classes based on the default Locale before it selects the base class (ButtonLabel).
getBundle이 classes의 이전 list안에서 일치하는 것을 못찾으면MissingResourceException을 던진다. 이 예외를 피하기 위해 접미사가 없는 base class를 항상 제공해야 한다.

The ListResourceBundle and PropertyResourceBundle Subclasses
Abstract class ResourceBundle은 2개의subclass를 갖는다.
PropertyResourceBundle과 ListResourceBundle이다
PropertyResourceBundle은 properties file로부터 지원받는다. Properties file은 변환할 수 있는 text를 담은 plain-text file이다.
Properties files는 java source code의 일부가 아니고 오직 String object를 위한 value를 담을 수 있다. 다른 종류의 object를 저장하기 원한다면 ListResourceBundle를 대신 사용한다.
ListResourceBundle class는 사용하기 편리한 list로 resources를 관리한다. 각각의 ListResourceBundle은  class file로 부터 지원받는다. ListResourceBundle안에 모든 독특한 locale object를 저장할 수 있다. To add support for an additional Locale, you create another source file and compile it into a class file.
ResourceBundle class는 유연하다. PropertyResourceBundle안에 Locale-specific String object를 처음 넣고 나중에 ListResourceBundle을 사용하기로 결정했을 때 code에는 아무런 충돌이 없다. ButtonLabel이 class로부터 지원받던 properties file로부터 지원받던 상관없이 getBundle을 호출해서 적합한 Locale을 위해 ResourceBundle을 찾아올 수 있다.
ResourceBundle introLabels =
    ResourceBundle.getBundle("ButtonLabel", currentLocale);

Key-Value Pairs
ResourceBundle object는 key-value pairs의 array를 담고있다. ResourceBundle로부터 값을 찾아오기 원한다면 Key를 열거한다. 단 반드시 String이 되야 한다.
Value는 locale-specific object이다. 아래 예제에서 keys는 OkKey와 CancelKey이다
class ButtonLabel_en extends ListResourceBundle {
    // English version
    public Object[][] getContents() {
	return contents;
    }
    static final Object[][] contents = {
	{"OkKey", "OK"},
	{"CancelKey", "Cancel"},
    };
}
ResourceBundle로부터 OK String을 찾아내기 위해서 getString을 호출할 때 적합한 key를 명시한다.
String okLabel = ButtonLabel.getString("OkKey");
Properties file은 key-value pairs를 담고 있다. Key는 “=”의 왼쪽이고 value는 오른쪽이다. 각각의 pair는 line으로 자른다. Value는 아마 String object만 표현할 수 있다. 다음 예제는 ButtonLabel.properties로 지어진 properties file의 내용이다
OkKey = OK
CancelKey = Cancel

Preparing to Use a ResourceBundle
Identifying the Locale-Specific Objects

Working with Text

checking character properties
문자type을 확인하기 위해 variable과 riteral의 직접비교는 영어와 몇몇 언어를 제외하고 정확한 방식이 아니다
Character class의 isLetter/Digit/SpaceChar method를 사용해 검사해야 한다
Character class의 methods는 Unicode표준을 기반으로 하기 때문에 신뢰할 수 있다
Unicode는 16bit character encoding은 세계의 대부분 언어들을 지원한다
java language에서 char value는 Unicode characters로 표현한다
Character class의 method로 char의 properties를 검사한다면 이것으로 작성한 code로 전세계 대부분의 언어를 작업할 수 있다.
유용한 methods는
isDigit/Letter/LetterOrDigit/LowerCase/UpperCase/SpaceChar/Defined 가 있다.

comparing strings
application을 영어권 사람들을 대상으로 제한한다면 String.compareTo method로 문자열비교를 수행할 수 있다. String.compareTo method는 두개 문자열의 Unicode characters의 binary를 비교를 수행한다. 대부분 언어에서 binary comparison을 통해 문자열 정렬을 하는 것에 대한 결과는 신뢰할 수 없다. Unicode value는 characters의 순서와 일치하지 않는다.
다행히 Collator class가 다른 언어들에서도 string comparison을 수행할 수 있게 해준다.

performing locale-independent comparisons
비교rules를 문자열의 정렬순서를 정의한다
locale을 통한 rule을 따른다 다양한 언어들은 제각각 정렬순서가 다르게 때문이다.
Collator class에 의해 미리 정의된 비교rules가 제공되고 locale에 독립적으로 문자열들을 정렬할 수 있다.
instance를 얻기위해 Collator class의 getInstance method를 호출한다.
대부분 default locale로 생성한다.
Collator를 생성할 때 locale을 명시해서 정확하게 얻을 수있다.
getInstance method는 RuleBasedCollator를 반환한다. Collator의 구체적인 subclass이다.
RuleBasedCollator는 rules의 set을 담고 명시한 locale을 위한 정렬순서를 결정한다.
rules는 각각의 locale을 위해 미리정의되어 있다. rules는 RuleBasedCollator안에 캡슐화되어 있어 프로그램이 특별한 routines를 
Collator.compare method를 호출하면 locale에 독립적인 문자열 비교를 수행한다.
compare method는 integer결과를 반환한다. 앞의 문자열의 순서가 낮으면 -1, 두문자열이 일치하면 0, 뒤의 문자열의 순서가 높으면 1이다.
정렬 연산을 수행할 때 compare method를 사용한다

Customizing collation rules
사전정의된 collator rules를 사용해서 원하는 결과를 볼 수없다면 원하는 rules를 설계하고  RuleBasedCollator object에 할당할 수 있다.
직접제작한 비교 rules는 String object안에 담겨지고 RuleBasedCollator의 constructor로 넘겨진다.
< a < b < c < d 가 있으면 a는 b보다 낮고 c는 둘보다 높고 d도 이런식이다.
이제 compare method는 문자열을 비교할 때 Customized collation rules를 참조한다.
collation rule을 생성하기 위해 사용되는 전체문법은 훨씬 유연하고 복잡하다.
문법에 대한 설명은 RuleBasedCollator class API에 전부 나와있다.

Improving Collation Performance
문자열들이 많은 list를 정렬하는 것은 시간낭비가 심하다.
정렬 알고리즘이 반복적으로 문자열들을 비교한다면 CollationKey class를 사용해서 처리속도를 향상시킬 수 있다.
CollationKey oject는 String과 Collator를 얻기 위한 sort key를 표현한다. 두개의 CollationKey object를 비교하는 것은 sort keys의 bit비교를 수행하는데 Collator.compare method보다 비교가 더 빠르다.
하지만 CollationKey object를 생성하는 것은 시간이 요구된다.
한 문자열이 단지 한번 비교되었다면 Collator.compare가 더 나은 성능을 제공한다.

Detecting Text Boundaries
어떤 워드 프로세서의 단어잘라내기, character highlignting, 다음 문장으로 커서이동, 줄의 마지막과 단어를 엵기 같은 공용기능은 고려해야한다. 이 기능들을 수행하려면 문자열안에 논리적 경계들을 찾아낼수 있어야 한다. 이런 경계분석 routine을 직접작성하지 않아도 BreakIterator class에서 제공하는 methods에서 혜택을 얻을 수 있다.
About the BreakIterator Class
BreakIterator class는 locale에 예민한데 문자열의 경계는 언어를 따라 다르기 때문이다.
BreakIterator class는 다음 4가지 유형의 경계를 분석할 수 있다.
문자, 단어, 문장, 잠재적인 문장잘림.
instance를 얻기위해 각각의 factory method를 호출한다.
getCharacterInstance/WordInstance/SentenceInstance/LineInstance
각 instance는 단지 한 종류의 경계만 찾을 수 있다.
문자와 단어 경계위치를 동시에 원한다면 두개의 instance를 따로 만든다.
BreakIterator는 가상의 커서를 갖고 이 커서는 text의 한 문자열의 현재 경계의 point다.
previous, next methods로 text안에서 커서를 움직일 수 있다.
getWordInstance로 BreakIterator를 생성했다면 next method가 호출될 때마다 커서는 text안에서 다음 번 단어경계로 이동한다. 커서이동 methods는 경계의 위치를 가리키는 정수를 반환한다. 이 위치는 text string안에 있는 문자의 index로 이것은 경계를 쫓는다.
string index들같은 경계들은 0을 기준으로 한다.첫 경계는 0이고 마지막 경계는 문자열의 전체길이값이다. 
next, previous methods에 의해 찾아진 단어경계들이다
  
BreakIterator class는 인간언어 text에만 사용할 수 있다.
programming language를 토큰화하기 위해서는 StreamTokenizer class를 사용한다.

Character Boundaries
개별적인 characters의 highlighting과 text에서 한 character씩 커서가 이동하도록 해야 한다면 characters의 경계들의 위치를 알아내는 것이 필요하다.
BreakIterator를 생성하는 것은 character 경계들의 위지를 알아내고 
character가 하나 이상의 Unicode character로 조합되어 있을 수 있다. 
ü같은 캐릭터는 Unicode character \u0075 (u) 와 \u00a8 (¨) 가 결합되어져 있다.
최상의 예는 아니다. single Unicode character \u00fc 에 의해 표현할 수 있기 때문이다.
  집을 의미하는 아라비아어다.
이 단어는 세개의 character를 담고 있다. 그러나 6개 Unicode character로 조합되었다.
String house = "\u0628"+"\u064e"+"\u064a"+"\u0652"+"\u067a"+"\u064f";
house string안의 Unicode characters중 1,3과 5번째 character는 구별자다.
아라비아어는 구별자가 필요한데 이것들로 단어의 의미를 바꿀수 있다. 위 예제에서 구별자는 nonspacing characters인데 base characters 위에 나타나기 때문이다.
string안에서 characters을 스캔하기위해서는 반드시 BreakIterator를 사용해야 한다.
BreakIterator를 사용해 위예제의 경계를 얻어내면 0,2,4,6이 나온다.
구별자 1,3,5는 list에 포함되지 않는다.

Word Boundaries
단어 경계들을 찾는 BreakIterator의 instance를 얻기위해 getWordInstance method를 호출한다.
단어들 각각에 연산을 수행해야 할 필요가 있다. 워드 프로세서의 공통기능인 selecting, cutting, pasting, copying, word search와 단순한 문자열에서 전체 단어들을 반드시 구분할 수 있어야 한다.
BreakIterator가 단어경계들을 분석할 때 단어들과 characters 사이를 구별하는 것은 단어들의 일부가 아니다.
spaces, tabs, punctuation marks, most symbols 가 양쪽단어경계를 갖는다.
다음예제는 target string아래에 ^문자에 의해 단어경계가 표시된다.
She stopped.   She said,   "Hello there,"   and then went on.
^   ^^          ^^ ^   ^^     ^^^^      ^^      ^^^^    ^^    ^^     ^^ ^^

Sentence Boundaries
문장경계들을 결정하기 위해 BreakIterator를 사용할 수 있다.
getSentenceInstance method로 BreakIterator의 instance를 얻는 것으로 시작한다.
구체적인 내용은 Word Boundaries에서 다룬 내용과 같다.
다음 예제는 target문장에 ^문자에 의해 문장경계가 표시된다.
She stopped.  She said, "Hello there," and then went on.
^                   ^                                                          ^
He's vanished!  What will we do?  It's up to us.
^                      ^                        ^                ^

Please add 1.5 liters to the tank.
^                                             ^

Line Boundaries
서식text같은 것들을 line wrapping하려면 잠재적인 줄바꿈 위치를 반드시 찾아내야 한다.
getLineInstance method로 BreakIterator instnace를 얻어 줄바꿈 위치 혹은 경계들을 찾아낼 수 있다.
BreakIterator는 string안에서 다음 line과 연결되어 잘려진 text의 위치를 결정한다.
BreakItertor에 의해 찾아진 위치는 잠재적인 줄바꿈들이다. 진짜 줄바꿈들은 아마 같지않게 screen에 출력되어있다.
다음 예제는 line경계밑에 ^문자가 표시된다.
BreakIterator에 따라 한line경계는 whitespace characters(space, tab, new line)의 한 순서가 종료한뒤에  line경계가 발생한다.
She stopped.  She said, "Hello there," and then went on.
^     ^             ^    ^       ^       ^       ^ ^     ^      ^      ^   ^
잠재적인 줄바꿈도 마찬가지로 -문자뒤에 즉시 일어난다 .

Converting Non-Unicode Text
java에서 char value는 Unicode characters로 표현한다.
Unicode는 16bit character encoding으로 전세계의 대부분 언어들을 지원한다.
http://www.unicode.org/index.html 에서 Unicode표준에 대해 자세히 배울수 있다.
몇몇 text editors는 Unicode text entry를 일반적으로 지원한다
Unicode character는 ASCII에서 나타내는 것은 불가능한데 ö같은 문자들을 \uXXXX형식의 escape sequence로 표현되기 때문이다. 각각의 X는 16진수 escape sequence다.
전세계의 systems마다 character encoding들이 다양하게 사용된다.
가장 일반적으로 사용되기 적합한 encoding이 Unicode다. 프로그램이 Unicode안의 characters를 기대하고 text data가 반드시 Unicode로 변환된 system으로 부터 얻고 반대로도 할 수 있다.
JVM의 default file encoding과 일치하면 text files의 data는 자동으로 Unicode로 변환된다
OutputStreamWirter를 사용해 default encoding을 식별할 수 있다.
default encoding이 원하는 encoding처리방식과 다르다면 반드시 직접 변환을 수행해야 한다.
다른 나라/platform에서 text를 처리할 때 변환작업이 필요할 수 있다.

Byte Encodings and Strings
non-Unicode를 Unicode로 변환하기 위한 2가지 기법이다.
non-unicode byte array를 String object에 넣을 수 있다. 반대로도 된다. 혹은 Unicode characters의 stream과 non-Unicode text byte stream간 변환할 수 있다.

byte array에 non-Unicode text를 담고 있다면 String constructor method로 Unicode text로 변환할 수 있다. 
String object에 집어넣은 non-Unicode characters를 getBytes method로 변환할 수 있다.
getBytes method의 parameter로 encoding identifier를 지정한다.
Input/Output Stream object를 만들 때 원하는 byte encoding을 정할 수 있다.
encoding identifier 를 생략하면 default encoding으로 읽는다.
어떤 encoding으로 사용해야 하는지 결정하려면 InputStreamReader object에 getEncoding()method를 호출하여 encoding identifier를 확인한다.

Normalizer's API***
정규화는 조화될 수 있게 만드는 text의 정확한 변형을 수행할 수 에 의해 처리한다.
정규화될 수 있는 것은 무엇일까 정규화는 구별자로 characters의 변환이 필요할 때 적용할 수 있고 전체 letters case를 바꾸고, 조합된 것을 분해하고, half width katakana characters를 full width katakana로 변환한다.
Normalizer's API는 java.text.Normalizer.Form에서 4가지 Unicode text 정규화 forms을 따르는 것을 모두 지원한다.
NFC - Normalization Form Composition (정규화 형태 조합)
NFD - Normalization Form Decomposition (정규화 형태 분해)
NFKC - Normalization Form Canonical Composition (정규화 형태 표준 조합)
NFKD - Normalization Form Canonical Decomposition (정규화 형태 표준 분해)
latin small letter "o" 를 어떻게 normalization forms를 사용해 정규화되게 만들 수 있는지 


Original word	NFC	NFD	NFKC	NFKD
"schön"	"schön"	"scho\u0308n"	"schön"	"scho\u0308n"
표를 보고 알 수 있듯이 원본 단어는 NFC와 NFKC에서 바뀌지않고 남아있다.
NFD와 NFKD 조합 characters는 그것들의 표준 분해로 mapped된다. 그러나 

half-width와 full-width katakana characters는 비슷하게 호환되는 분해와 
이렇다 하더라도 표준적으로 동등하지 않다